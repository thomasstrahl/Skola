#!/usr/bin/perl -w
# dimacs2minizinc data converter
# andrew slater november 2006
#
# not guaranteed to work with badly formed input
#


if ($#ARGV !=1) {
    die "Usage:  $0 inputfile outputfile\n";
}
($infile,$outfile) = @ARGV;
if (! -r $infile) {
    die "Can't read input $infile\n";
}
if (! -f $infile) {
    die "Input $infile is not a plain file\n";
}
open(INPUT,"<$infile") ||
    die "Can't input $infile $!";
open(OUTPUT,">$outfile") ||
    die "Can't output $outfile $!";


print OUTPUT "\%\n\% SAT instance based on a DIMACS SAT problem generated by $0\n\%\n";

my $line = "";
chomp($line = <INPUT>);
while ($line !~ /^p/) {
    chomp($line = <INPUT>);
}

my @linebits = split(/ /,$line);
my $numVars = $linebits[2];
my $numClauses = $linebits[3];

print OUTPUT "\% boolean variables\n";
print OUTPUT "array [1..$numVars] of var bool : assignment;\n";
#print OUTPUT "int: NumVars = $numVars;\n";
#print OUTPUT "int: NumClauses = $numClauses;\n";
print OUTPUT "\% formula\n";

my @cb;
my @ce;
my @f;
my $clause_count = 0;
my $element_count = 0;
$cb[0] = 1;
while (<INPUT>) {
    @linebits = split;#(/\ */ ,$_);
    for ($i = 0; $i <= $#linebits; $i++){
	if (($linebits[$i] + 0) == 0) {
	    $ce[$clause_count] = $element_count;
	    $cb[$clause_count+1] = $element_count+1;
	    $clause_count++;
	}
	else {
	    $f[$element_count] = $linebits[$i]; 
	    $element_count++;
	}
    }
}

print OUTPUT "array [1..$element_count] of int: Formula = [ ";
for ($i = 0; $i < ($element_count-1); $i++){
    print OUTPUT "$f[$i], ";
}
print OUTPUT $f[$element_count-1]." ];\n";

print OUTPUT "\n\%\n\% constraints\n\%\n\n";
for ($i=0;$i<$clause_count;$i++){
    print OUTPUT "\% clause ".($i+1)."\n";    
    print OUTPUT "constraint (\n";
    my $j;
    for ($j = $cb[$i]; $j < $ce[$i]; $j++){
	print OUTPUT
	    "  ( ( Formula[$j] > 0 ) == assignment[".abs($f[$j-1])."] ) \\/ \n";
    }
    print OUTPUT "  ( ( Formula[$j] > 0 ) == assignment[".abs($f[$j-1])."] )\n);\n";

}

print OUTPUT "\nsolve satisfy;\n";

close INPUT;
close OUTPUT;



